---
import {Icon} from 'astro-iconify';
import {SITE} from '~/config.mjs';
import Layout from '~/layouts/PageLayout.astro';
import OverflowMenu from '~/components/widgets/OverflowMenu.astro';
import Announcement from '~/components/widgets/Announcement.astro';
import PressQuotes from '~/components/widgets/PressQuotes.astro';
import RelatedApps from '~/components/widgets/RelatedApps.astro';
import {fetchApps, proseCSS, tagCSS} from '~/utils/apps.js';

export async function getStaticPaths() {
	const apps = await fetchApps({includeArchived: true, includeUnlisted: true});
	const allApps = apps.filter(app => !app.isArchived && !app.isUnlisted);

	return apps.map(app => ({
		params: {
			slug: app.slug,
		},
		props: {
			app,
			allApps,
		},
	}));
}

const {app, allApps} = Astro.props;

const meta = {
	title: `${app.title} — ${SITE.name}`,
	description: app.subtitle,
	image: `/og/${app.slug}.png`,
	ogTitle: app.title,
	ogType: 'product',
	appStoreId: app.appStoreId,
	favicon: app.iconUrl,
	rssFeeds: !app.isArchived && app.releasesRepo ? [
		{
			title: `${app.title} Release Notes`,
			href: `/${app.slug}/rss.xml`,
		},
	] : [],
};

const {title: appTitle, appStoreUrl} = app;

const hasMainLinks = Object.keys(app.mainLinks).length > 0;
const providerCount = [app.appStoreId, app.setappId, hasMainLinks].filter(Boolean).length;
const hasDownload = !app.isArchived && providerCount > 0;
const downloadUrl = providerCount === 1 ? (app.appStoreUrl ?? app.setappUrl ?? Object.values(app.mainLinks)[0]) : undefined;

const overflowItems = [
	...Object.entries(app.overflowLinks ?? {}).map(([title, url]) => ({title, url})),
	...(!app.isArchived && app.appStoreId ? [{title: 'What\'s New', url: app.appStoreUrl}] : []),
	...(!app.isArchived && app.releasesRepo ? [{title: 'Release Notes', url: `/${app.slug}/release-notes`}] : []),
	...(app.isArchived ? [] : [{title: 'Privacy Policy', url: `/${app.slug}/privacy-policy`}]),
	{title: 'Terms of Use', url: '/apps/terms'},
	...(app.isPaid ? [{title: 'Discounts', url: '/apps/discounts'}] : []),
];

// Skip "Available on macOS" when the requirement already mentions macOS and it's the only platform.
const requirementMentionsMacOS = app.requirement?.toLowerCase().includes('macos');
const skipPlatforms = requirementMentionsMacOS && app.platforms.length === 1 && app.platforms[0] === 'macOS';
const platformText = !skipPlatforms && app.platforms.length > 0 ? `Available on ${app.platforms.join(', ')}` : '';
const availabilityText = [platformText, app.requirement].filter(Boolean).join(' — ');

const tagClass = tagCSS;
---

<Layout {meta}>
	<section class="max-w-5xl py-8 sm:py-16 lg:py-20 mx-auto lg:-mt-10 mb-10">
		<article itemscope itemtype="https://schema.org/SoftwareApplication" data-heading-anchors>
			<header id="app-hero" class="flex flex-col items-center text-center px-4 sm:px-6 mb-40">
				<img id="app-icon" src={app.iconUrl} width="256" height="256" alt={`${app.title} app icon`} class="p-[16px] drop-shadow-[0_2px_4px_rgba(0,0,0,0.1)] mb-3">
				<h1 class="text-5xl md:text-7xl font-bold tracking-tight mb-4 font-heading" itemprop="name">
					{app.title}
				</h1>
				<h2 class="text-2xl md:text-4xl tracking-tight font-normal text-gray-700 dark:text-gray-300 max-w-2xl mx-auto mb-8" itemprop="description" style="text-wrap: pretty; hanging-punctuation: first last">
					{app.subtitle}
				</h2>
				<div id="another-random-app" class="flex justify-center hidden instapaper_ignore">
					<a href="/apps/random"
						class="flex items-center gap-2 px-4 py-2 mb-6 font-semibold text-white bg-linear-to-r from-primary-500 to-secondary-500 rounded-full shadow-xs hover:shadow-md hover:from-primary-600 hover:to-secondary-600 focus:outline-hidden focus:ring-4 focus:ring-blue-300 dark:focus:ring-blue-800">
						<Icon name="tabler:arrows-shuffle" class="w-5 h-5" aria-hidden="true"/>
						Another Random App
					</a>
				</div>
				{app.isArchived &&
					<span class={`${tagClass} bg-orange-100 dark:bg-orange-200 text-[16px] mb-10`}>archived</span>
				}
				{(app.appStoreId || app.setappId || hasMainLinks) &&
					<nav class="flex flex-col sm:flex-row gap-x-4 gap-y-8 mt-2 instapaper_ignore" aria-label="Download options">
						<>
							{!app.isArchived && app.appStoreId &&
								<div class="relative download-badge">
									<button id="share-button" class="hidden absolute inset-0 left-[-26px] opacity-90" style="width:16px">
										<Icon name="tabler:share-2" class="w-4"/>
									</button>
									<a href={app.appStoreUrl}>
										<img src="/assets/download-on-app-store-badge.svg" alt="Download on the App Store" style="margin: 0; padding: 0; display: block; height: 60px; user-select: none">
									</a>
								</div>
							}
						</>
						<>
							{!app.isArchived && app.setappId &&
								<a href={app.setappUrl} class="download-badge">
									<img src="/assets/download-on-setapp-badge.svg" alt="Download on Setapp" style="margin: 0; padding: 0; display: block; height: 60px; user-select: none">
								</a>
							}
						</>
						{hasMainLinks &&
								<>
									<!-- We apply a fixed size so it matches the App Store button. -->
									{Object.entries(app.mainLinks).map(([title, url]) => (
										<a href={url} class="download-badge text-white bg-primary-700 hover:bg-primary-600 focus:ring-4 focus:outline-hidden focus:ring-blue-300 dark:focus:ring-blue-800 font-bold rounded-lg text-xl px-6 text-center mb-2 flex justify-center items-center whitespace-nowrap px-10 py-4" style="width: 180px; height: 60px;">{title}</a>
									))}
								</>
						}
					</nav>
				}
				{Object.keys(app.links).length > 0 &&
					<nav class="flex flex-wrap gap-4 max-w-md justify-center mt-8 text-xl font-semibold text-primary-600 dark:text-primary-400 instapaper_ignore" aria-label="App links">
						<>
							{Object.entries(app.links).map(([title, url]) => (
								<a href={url} class="underline underline-offset-4 decoration-transparent hover:decoration-primary-500/50 hover:text-primary-600 dark:hover:text-primary-300 transition-colors">{title}</a>
							))}
						</>
						<OverflowMenu overflowItems={overflowItems}>
							<hr>
							<option value="/apps/random">Show Random App</option>
						</OverflowMenu>
					</nav>
				}
			</header>
			{availabilityText &&
				<p class="text-center text-sm text-gray-500 dark:text-gray-500 -mt-24 mb-32">{availabilityText}</p>
			}
			{app.announcement &&
				<Announcement text={app.announcement.text} url={app.announcement.url} urlText={app.announcement.urlText}/>
			}
			<div class="relative group/carousel mx-auto max-w-5xl mb-20">
				<section id="app-media" class="px-6 flex gap-4 overflow-x-auto snap-x snap-mandatory scrollbar-hide" aria-label="App media">
					{app.videos.map(video => (
						<div class="snap-center shrink-0 w-[85vw] md:w-full md:flex md:justify-center">
							<video src={video} autoplay loop muted playsinline preload="metadata" aria-label={`${app.title} demo video`} class="rounded-md shadow-lg w-full md:h-[640px] md:w-auto md:max-w-full"/>
						</div>
					))}
					{app.screenshots.map((screenshot, index) => (
						<div class="snap-center shrink-0 w-[85vw] md:w-full md:flex md:justify-center">
							<img src={screenshot.src} width={screenshot.width} height={screenshot.height} alt={`${app.title} screenshot ${index + 1}`} loading="lazy" class="rounded-md shadow-lg w-full md:h-[640px] md:w-auto md:max-w-full">
						</div>
					))}
				</section>
				<button class="media-prev hidden md:flex items-center justify-center absolute left-8 top-1/2 -translate-y-1/2 z-10 w-12 h-12 rounded-full bg-white/40 dark:bg-gray-900/40 backdrop-blur-sm shadow-md text-gray-700 dark:text-gray-200 opacity-0 group-hover/carousel:opacity-100 transition-opacity cursor-default" aria-label="Previous screenshot">
					<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><polyline points="15,18 9,12 15,6"/></svg>
				</button>
				<button class="media-next hidden md:flex items-center justify-center absolute right-8 top-1/2 -translate-y-1/2 z-10 w-12 h-12 rounded-full bg-white/40 dark:bg-gray-900/40 backdrop-blur-sm shadow-md text-gray-700 dark:text-gray-200 opacity-0 group-hover/carousel:opacity-100 transition-opacity cursor-default" aria-label="Next screenshot">
					<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><polyline points="9,6 15,12 9,18"/></svg>
				</button>
			</div>
			{app.pressQuotes?.length > 0 &&
				<PressQuotes quotes={app.pressQuotes}/>
			}
			<div class={proseCSS}>
				<app.Content/>
			</div>
			<div class="mx-auto px-6 max-w-3xl">
				<RelatedApps currentApp={app} allApps={allApps}/>
			</div>
		</article>
	</section>
	<div id="app-nav-content" class="absolute inset-0 flex py-3 px-3 mx-auto w-full justify-between max-w-6xl md:px-4 items-center text-gray-600 dark:text-slate-200" style="filter: opacity(0); pointer-events: none;">
		<a href={app.url} class="flex items-center gap-3 shrink-0">
			<img src={app.iconUrl} width="32" height="32" alt="" class="rounded-lg">
			<span class="font-bold text-lg text-gray-900 dark:text-white whitespace-nowrap hidden lg:inline">{app.title}</span>
		</a>
		<nav class="flex items-center">
			{Object.entries(app.links).map(([title, url]) => (
				<a href={url} class="hidden md:flex font-medium hover:text-gray-900 dark:hover:text-white px-4 py-3 items-center whitespace-nowrap underline underline-offset-[7px] decoration-[3px] decoration-transparent transition-[text-decoration-color] duration-500 ease-in-out">{title}</a>
			))}
			<div class="hidden md:flex px-4">
				<OverflowMenu overflowItems={overflowItems} iconClassName="text-gray-600 dark:text-slate-200">
					<hr>
					<option value="/apps/random">Show Random App</option>
				</OverflowMenu>
			</div>
			{hasDownload && downloadUrl &&
				<a href={downloadUrl} class="relative z-10 ml-4 text-white bg-primary-700 hover:bg-primary-600 font-bold rounded-full text-sm px-5 py-2 whitespace-nowrap">Get</a>
			}
			{hasDownload && !downloadUrl &&
				<button type="button" class="relative z-10 ml-4 text-white bg-primary-700 hover:bg-primary-600 font-bold rounded-full text-sm px-5 py-2 whitespace-nowrap cursor-pointer" onclick="window.scrollTo({top: 0})">Get</button>
			}
		</nav>
	</div>
	<script type="application/ld+json" set:html={JSON.stringify({
		'@context': 'https://schema.org',
		'@type': 'SoftwareApplication',
		applicationCategory: app.platforms.includes('macOS') ? 'UtilitiesApplication' : 'MobileApplication',
		name: app.title,
		operatingSystem: app.platforms.join(', '),
		author: {
			'@type': 'Person',
			givenName: 'Sindre',
			familyName: 'Sorhus',
			url: 'https://sindresorhus.com',
			sameAs: [
				'https://github.com/sindresorhus',
				'https://x.com/sindresorhus',
				'https://mastodon.social/@sindresorhus',
				'https://bsky.app/profile/sindresorhus.com',
			],
		},
		datePublished: new Date(app.pubDate).toISOString().split('T')[0],
		description: app.description || app.subtitle,
		url: `https://sindresorhus.com${app.url}`,
		image: `https://sindresorhus.com${app.iconUrl}`,
		...(app.appStoreId && {downloadUrl: app.appStoreUrl}),
		...(app.screenshots.length > 0 && {
			screenshot: app.screenshots.map(s => `https://sindresorhus.com${s.src}`),
		}),
		...(app.appStoreId && {
			offers: {
				'@type': 'Offer',
				availability: 'https://schema.org/InStock',
				url: app.appStoreUrl,
				seller: {
					'@type': 'Person',
					name: 'Sindre Sorhus',
				},
				...(app.isPaid && {
					priceCurrency: 'USD',
				}),
			},
		}),
	}, null, '\t')} />
</Layout>

<script type="module" is:inline define:vars={{appTitle, appStoreUrl}}>
	const shareData = {
		title: appTitle,
		url: appStoreUrl
	};

	if (navigator.canShare(shareData)) {
		const shareButton = document.querySelector('#share-button');

		shareButton.style.display = 'block';

		shareButton.addEventListener('click', async () => {
			try {
				await navigator.share(shareData);
			} catch (error) {
				console.error('Share failed:', error.message);
			}
		});
	}
</script>

<script type="module" is:inline>
	if (document.referrer.endsWith('/apps/random')) {
		document.querySelector('#another-random-app').style.display = 'flex';
	}
</script>

<script type="module" is:inline>
{
	// 3D tilt effect on the app icon.
	// Uses lerp for buttery smooth interpolation. Requires a short dwell time
	// before activating so quick mouse fly-overs are ignored.
	// A grace area around the icon keeps the effect alive when slightly outside bounds.
	const icon = document.querySelector('#app-icon');

	if (icon && !matchMedia('(prefers-reduced-motion: reduce)').matches) {
		const maxTilt = 36;
		const lerpFactor = 0.1;
		const dwellTime = 300;
		const gracePadding = 40;
		const clamp = (value, min, max) => Math.min(Math.max(value, min), max);
		const lerp = (current, target, factor) => current + (target - current) * factor;

		// Animated properties: [current, target]
		const state = { x: 0, y: 0, scale: 1, shadowX: 0, shadowY: 0, shadowBlur: 0, shadowOpacity: 0 };
		const target = { ...state };
		let activated = false;
		let hovering = false;
		let animating = false;
		let dwellTimer;

		icon.style.willChange = 'transform, filter';
		icon.parentElement.style.perspective = '800px';

		// Capture the existing Tailwind drop-shadow so we can preserve it.
		const baseFilter = getComputedStyle(icon).filter;
		const hasBaseFilter = baseFilter && baseFilter !== 'none';

		const animate = () => {
			// Compute targets fresh each frame.
			if (activated) {
				target.x = cursorX;
				target.y = cursorY;
				target.scale = 1.1;
				target.shadowX = -cursorX * 20;
				target.shadowY = -cursorY * 20;
				target.shadowBlur = 30;
				target.shadowOpacity = 0.25;
			} else {
				Object.assign(target, { x: 0, y: 0, scale: 1, shadowX: 0, shadowY: 0, shadowBlur: 0, shadowOpacity: 0 });
			}

			for (const key of Object.keys(state)) {
				state[key] = lerp(state[key], target[key], lerpFactor);
			}

			icon.style.transform = `rotateY(${state.x * maxTilt}deg) rotateX(${-state.y * maxTilt}deg) scale3d(${state.scale}, ${state.scale}, ${state.scale})`;

			// Shadow shifts opposite to tilt, as if light comes from above.
			const tiltShadow = `drop-shadow(${state.shadowX}px ${state.shadowY + 10}px ${state.shadowBlur}px rgba(0,0,0,${state.shadowOpacity}))`;
			icon.style.filter = hasBaseFilter ? `${baseFilter} ${tiltShadow}` : tiltShadow;

			const settled = Object.keys(state).every(key => Math.abs(state[key] - target[key]) < 0.005);

			if (settled) {
				animating = false;
				if (!activated) {
					icon.style.transform = '';
					icon.style.filter = '';
					Object.assign(state, { x: 0, y: 0, scale: 1, shadowX: 0, shadowY: 0, shadowBlur: 0, shadowOpacity: 0 });
				}
			} else {
				requestAnimationFrame(animate);
			}
		};

		const startAnimating = () => {
			if (!animating) {
				animating = true;
				requestAnimationFrame(animate);
			}
		};

		// Cursor position relative to icon center, updated on every mousemove.
		let cursorX = 0;
		let cursorY = 0;

		icon.addEventListener('mouseenter', () => {
			hovering = true;
			dwellTimer = setTimeout(() => {
				if (hovering) {
					activated = true;
					startAnimating();
				}
			}, dwellTime);
		});

		// Listen on document to track cursor in the grace area outside the icon.
		document.addEventListener('mousemove', (event) => {
			const rect = icon.getBoundingClientRect();
			cursorX = clamp((event.clientX - rect.left) / rect.width - 0.5, -0.5, 0.5);
			cursorY = clamp((event.clientY - rect.top) / rect.height - 0.5, -0.5, 0.5);

			if (activated) {
				// Deactivate if cursor leaves the grace area.
				const inGrace = event.clientX >= rect.left - gracePadding
					&& event.clientX <= rect.right + gracePadding
					&& event.clientY >= rect.top - gracePadding
					&& event.clientY <= rect.bottom + gracePadding;

				if (!inGrace) {
					hovering = false;
					activated = false;
					clearTimeout(dwellTimer);
				}

				startAnimating();
			}
		}, {passive: true});

		icon.addEventListener('mouseleave', () => {
			hovering = false;
			clearTimeout(dwellTimer);
		});
	}
}
</script>

<script type="module" is:inline>
{
	const siteHeader = document.querySelector('#site-header');
	const siteNav = document.querySelector('#site-nav-content');
	const appNav = document.querySelector('#app-nav-content');
	const hero = document.querySelector('#app-hero');

	if (siteHeader && siteNav && appNav && hero) {
		siteHeader.appendChild(appNav);

		// Uses `filter: opacity()` instead of `opacity` property because the header's
		// `backdrop-filter` creates a backdrop root that blocks opacity animations.
		const setOpacity = (element, value) => {
			element.style.filter = value < 1 ? `opacity(${value})` : '';
			element.style.pointerEvents = value < 1 ? 'none' : '';
		};

		const fadeTo = (element, target) => {
			element.animate(
				[
					{filter: `opacity(${target < 1 ? 1 : 0})`},
					{filter: `opacity(${target})`},
				],
				{duration: 400, easing: 'ease-in-out'},
			).onfinish = () => setOpacity(element, target);
		};

		const mobileQuery = window.matchMedia('(max-width: 767px)');
		let showing = false;

		new IntersectionObserver(([entry]) => {
			const shouldShow = !entry.isIntersecting && !mobileQuery.matches;

			if (shouldShow === showing) {
				return;
			}

			showing = shouldShow;

			if (shouldShow) {
				fadeTo(siteNav, 0);
				fadeTo(appNav, 1);
			} else {
				fadeTo(appNav, 0);
				fadeTo(siteNav, 1);
			}
		}).observe(hero);

		// Scroll-spy: highlight the active section link in the app nav.
		const navLinks = appNav.querySelectorAll('a[href^="#"]');
		const headings = [...document.querySelectorAll('article h2[id]')];
		const activeColor = getComputedStyle(document.documentElement).getPropertyValue('--color-secondary-500').trim();

		if (navLinks.length > 0 && headings.length > 0) {
			document.addEventListener('scroll', () => {
				let activeId;

				// At the bottom of the page, activate the last section since it may not scroll far enough to trigger normally.
				const isAtBottom = (window.innerHeight + window.scrollY) >= (document.documentElement.scrollHeight - 2);
				if (isAtBottom) {
					activeId = headings.at(-1).id;
				} else {
					// Find the last heading that has scrolled past the top of the viewport.
					for (const heading of headings) {
						if (heading.getBoundingClientRect().top < 100) {
							activeId = heading.id;
						}
					}
				}

				// Underline the active nav link, clear the rest.
				for (const link of navLinks) {
					const isActive = link.getAttribute('href') === `#${activeId}`;
					link.style.textDecorationColor = isActive ? activeColor : 'transparent';
				}
			}, {passive: true});
		}
	}
}
</script>

<script type="module" is:inline>
(() => {
	const carousel = document.querySelector('#app-media');
	if (!carousel) {
		return;
	}

	const previousButton = document.querySelector('.media-prev');
	const nextButton = document.querySelector('.media-next');
	const items = [...carousel.querySelectorAll(':scope > *')];

	if (items.length === 0) {
		return;
	}

	let currentIndex = 0;

	const getVisualIndex = () => {
		const containerCenter = carousel.getBoundingClientRect().left + carousel.offsetWidth / 2;
		let closestIndex = 0;
		let minimumDistance = Infinity;
		for (const [index, item] of items.entries()) {
			const {left, width} = item.getBoundingClientRect();
			const distance = Math.abs(left + width / 2 - containerCenter);
			if (distance < minimumDistance) {
				minimumDistance = distance;
				closestIndex = index;
			}
		}
		return closestIndex;
	};

	const setButtonHidden = (button, isHidden) => {
		button.style.opacity = isHidden ? '0' : '';
		button.style.pointerEvents = isHidden ? 'none' : '';
	};

	const updateBoundaries = () => {
		setButtonHidden(previousButton, currentIndex === 0);
		setButtonHidden(nextButton, currentIndex === items.length - 1);
	};

	const scrollToIndex = (index) => {
		currentIndex = Math.max(0, Math.min(items.length - 1, index));
		items[currentIndex].scrollIntoView({behavior: 'smooth', block: 'nearest', inline: 'center'});
		updateBoundaries();
	};

	previousButton.addEventListener('click', () => {
		scrollToIndex(currentIndex - 1);
	});
	nextButton.addEventListener('click', () => {
		scrollToIndex(currentIndex + 1);
	});

	// Sync index after user manually swipes so button state stays correct.
	carousel.addEventListener('scrollend', () => {
		currentIndex = getVisualIndex();
		updateBoundaries();
	}, {passive: true});

	updateBoundaries();
})();
</script>

<style is:global>
	.download-badge {
		transition: transform 0.2s ease, filter 0.2s ease;
	}

	.download-badge:hover {
		transform: scale(1.05);
		filter: brightness(1.1);
	}

	.download-badge:active {
		transform: scale(0.97);
		filter: brightness(0.95);
	}
</style>
